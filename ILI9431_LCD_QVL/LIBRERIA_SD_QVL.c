
#ifndef  SD_QVL_LIBRARYC
#define SD_QVL_LIBRARYC





/*ESTA FUNCION ES DE  SUMA IMPORTANCIA YA QUE PERMITE ARRANCARR LA TARJETA SD EN MODO SPI GENERANDO
UN TREN DE PULSOS IMPAR EN EL CLOCK DE LA SD PARA QUE ESTA SE ACTIVE EN MODO SPI*/
void RESET_SD_MMC(void){
for (int i=0;i!=1000;i++){PAUSE_FLUJO(0,1,0,1);PORTC^=(1<<PORTC3);}}




void INT_SD_MMC(void){
RESET_SD_MMC();
CUSTOM_CMD_SET_SD_MMC(0x00,0x00,0x00,0x95);/*CMD0 INICIALISACION DE LA SD/MMC*/
CUSTOM_CMD_SET_SD_MMC(0x01,0x00,0x00,0xff);/*CMD1 RESET DEL SOFTWRE DE LA SD/MMC*/
CUSTOM_CMD_SET_SD_MMC(0x10,0x00,0x200,0xff);/*CMD10 SET THE SIZE BLOCK*/
}

/*------------------------------------------------------------------*/
void BLOCK_MEMORY_SET_SD_MMC(int16_t CMD_ARGUMENT_MSB,int16_t CMD_ARGUMENT_LSB){
/*CMD0*//*50 00 000 00 08 ff*/
PORTC^=(1<<PORTC0);
/*CONFIGURACION DEL TAMAÑO DEL BLOQUE DE MEMORIA QUE SE USARA PARA GUARDAR DATOS VALOR ES DE DEFAULT 512 bytes*/
CUSTOM_CMD_SET_SD(10,0,512,0xff,0x00);
PORTC^=(1<<PORTC0);}

/*------------------------------------------------------------------*/
/*FUNCION DE SUMA IMPORTANCIA QUE SIRVE PARA ENVIAR COMANDOS A LA TARJETA SD TIENE COMO PARAMETROS
CMDX(ES PARA INDICARLE QUE ACCION VA A REALIZAR)1Byte
CMD_ARGUMENT_MSB(EL ARGUMENTO MAS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CMD_ARGUMENT_LSB(EL ARGUMENTO MENOS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CRC(SE LE ENVIA LA SUMA DE VERIFICACION DE LOS DATOS QUE SE ESTAN ENVIADO)1Byte
CON PINES DE SELET SLAVE INCORPORADOS EN LA FUNCION*/
uint16_t CUSTOM_CMD_SET_SD_MMC(uint8_t CMDX,uint16_t CMD_ARGUMENT_MSB,uint16_t CMD_ARGUMENT_LSB,uint8_t CRC){
/*CMD0*//*87 xx xx xx xx ff*/
uint8_t ERROR_SD=0;
PORTC^=(1<<PORTC0);
/*CONFIGURACION DEL TAMAÑO DEL BLOQUE DE MEMORIA QUE SE USARA PARA GUARDAR DATOS VALOR ES DE DEFAULT 512 bytes*/
CMDX=(CMDX);
CMDX=(CMDX|0b01000000);/*AQUI AJUSTAMOS EL BIT DE STAR DE DEL Byte DE COMANDO QUE SE LE ENVIE A LA SD*/
SPI_MASTER_TRANSMITION_8_BITS(CMDX);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_MSB);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_LSB);
SPI_MASTER_TRANSMITION_8_BITS(CRC);
ERROR_SD=SPI_RECEIVE_MODE_MASTER_16BITS_();
PORTC^=(1<<PORTC0);
return ERROR_SD;}




/*FUNCION DE SUMA IMPORTANCIA QUE SIRVE PARA ENVIAR COMANDOS A LA TARJETA SD TIENE COMO PARAMETROS
CMDX(ES PARA INDICARLE QUE ACCION VA A REALIZAR)1Byte
CMD_ARGUMENT_MSB(EL ARGUMENTO MAS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CMD_ARGUMENT_LSB(EL ARGUMENTO MENOS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CRC(SE LE ENVIA LA SUMA DE VERIFICACION DE LOS DATOS QUE SE ESTAN ENVIADO)1Byte
SIN PINES DE SELET SLAVE INCORPORADOS EN LA FUNCION*/
void CUSTOM_CMD_SET_SD(uint8_t CMDX,uint16_t CMD_ARGUMENT_MSB,uint16_t CMD_ARGUMENT_LSB,uint8_t CRC,uint8_t ERROR){
/*CMD0*/
/*87 xx xx xx xx ff*/
/*CONFIGURACION DEL TAMAÑO DEL BLOQUE DE MEMORIA QUE SE USARA PARA GUARDAR DATOS VALOR ES DE DEFAULT 512 bytes*/
CMDX=(CMDX);
CMDX=(CMDX|0b01000000);
SPI_MASTER_TRANSMITION_8_BITS(CMDX);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_MSB);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_LSB);
SPI_MASTER_TRANSMITION_8_BITS(CRC);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=ERROR);}



/*ESTA FUNCION ESCRIBE EN LA MEMORIA SD*/
void WRITE_MEMORY_SD_MMC(uint8_t DATA[],uint16_t SIZE_SECTOR,uint32_t NUM_SECTORE){
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(24,((NUM_SECTORE*SIZE_SECTOR)>>16),(NUM_SECTORE*SIZE_SECTOR),0xff,0x00);
SPI_MASTER_TRANSMITION_8_BITS(0xfe);
for(int i=0;i!=SIZE_SECTOR;i++){
SPI_MASTER_TRANSMITION_8_BITS(DATA[i]);}
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0x05);
PORTC^=(1<<PORTC0);}



/*ESTA FUNCION LEE UN SECTOR DE 512 Bytes EN LA MEMORIA SD Y COPIA EL CONTENIDO COPIADO EN OTRO SECTOR DE LA MEMORIA SD*/
void READ_AND_COPY_MEMORY_SD_MMC(uint16_t SIZE_SECTOR,uint32_t NUM_SECTORE,int COPY,uint32_t NUM_SECTORE_1){
uint8_t READ_DATA_0[SIZE_SECTOR];
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,((NUM_SECTORE*SIZE_SECTOR)>>16),(NUM_SECTORE*SIZE_SECTOR),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
for(int i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_0[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);
if(COPY){WRITE_MEMORY_SD_MMC(READ_DATA_0,SIZE_SECTOR,NUM_SECTORE_1);}}




/*ESTA FUNCION LEE UN SECTOR DE 512 Bytes EN LA MEMORIA SD*/
void READ_MEMORY_SD_MMC(uint16_t SIZE_SECTOR,uint32_t NUM_SECTORE){
uint8_t READ_DATA_1[SIZE_SECTOR];

PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,((NUM_SECTORE*SIZE_SECTOR)>>16),(NUM_SECTORE*SIZE_SECTOR),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
PAUSE_FLUJO(2000,1,0,1);
for(int i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_1[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);}


/*ESTA FUNCION SIRVE PARA BUSCAR EL SECTOR INICAL EN EL QUE SE ENCUENTRAN LOS DATOS DE ALGUN ARCHIVO DE LA MEMORIA SD*/
unsigned int SEARCH_CLUSTER_FILE(uint16_t SIZE_SECTOR, char*String_){																char NOMBRE_DEL_ARCHIVO[11],LUW4=0;


for(int i=0;i!=11;i++){
NOMBRE_DEL_ARCHIVO[i]=0x20;}


int i=0,EXTENCION_DEL_FILE=0;

char *LUW1,*LUW3;
LUW3=String_;




while(i!=8){

LUW4=pgm_read_byte(&LUW3[i]);
if(LUW4=='.'){EXTENCION_DEL_FILE=i;i=8;}
else{NOMBRE_DEL_ARCHIVO[i]=LUW4;
i++;}}


// for(int i=8;i!=11;i++){EXTENCION_DEL_FILE++;
// NOMBRE_DEL_ARCHIVO[i]=String_[EXTENCION_DEL_FILE]for(int i=8;i!=11;i++){EXTENCION_DEL_FILE++;
NOMBRE_DEL_ARCHIVO[i]=pgm_read_byte(&LUW3[EXTENCION_DEL_FILE]);}if(BPB_FATz16==0){FATSz=BPB_FATz32;}
else{FATSz=BPB_FATz16;}


if(TYPPE_FAT==16){FAT_Offset=READ_Root_Dir_MEMORY_SD_MMC(512,FirstRootDirSecNum,NOMBRE_DEL_ARCHIVO)*2;}else{if(TYPPE_FAT==32){FAT_Offset=READ_Root_Dir_MEMORY_SD_MMC(512,FirstRootDirSecNum,NOMBRE_DEL_ARCHIVO)*4;}}ThisFATSecNum=BPB_RsvdSecCnt+(FAT_Offset/FAT_32_16.BPB_BytsPerSec);ThisFATEntOffset=(FAT_Offset%FAT_32_16.BPB_BytsPerSec);SectorNumber=(FAT_32_16.BPB_NumFATs*FATSz)+ThisFATSecNum;
FAT16ClusEntryVal=0;



unsigned int NUMERO_DE_SECTOR=0;
uint8_t READ_FAT[SIZE_SECTOR];


PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,((ThisFATSecNum*SIZE_SECTOR)>>16),(ThisFATSecNum*SIZE_SECTOR),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
PAUSE_FLUJO(2000,1,0,1);
for(int i=0;i!=(SIZE_SECTOR);i++){
READ_FAT[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);



uint8_t FAT_L=0;

/*CON ESTAS CONDICIONES SE OPTIENE EL VALOR DE LA POSICION EN DECIMAL DE LA ENTRADA FAT CORRESPONDIENTE AL CLUSTER DESEADO FAT_Offset*/if(TYPPE_FAT==16){FAT_L=3;FAT16ClusEntryVal=READ_FAT[ThisFATEntOffset+1];FAT16ClusEntryVal=(FAT16ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset];FirstSectorOfCluster=((FAT16ClusEntryVal-FAT_L)*BPB_SecPerClus)+FirstDataSector;}else{FAT_L=3;FAT32ClusEntryVal=READ_FAT[ThisFATEntOffset+3];FAT32ClusEntryVal=(FAT32ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset+2];
FAT32ClusEntryVal=(FAT32ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset+1];
FAT32ClusEntryVal=(FAT32ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset];
FirstSectorOfCluster=((FAT32ClusEntryVal-FAT_L)*BPB_SecPerClus)+FirstDataSector;}



/*INDICA EL SECTOR INICIAL DONDE SE ALMACENAN LOS DATOS CORRESPONDIENTE A UN CLUSTER ESPESIFICO*///FirstSectorOfCluster=((FAT16ClusEntryVal-FAT_L)*BPB_SecPerClus)+FirstDataSector;
if(FAT_Offset==0){NUMERO_DE_SECTOR=FAT_Offset;}
else{NUMERO_DE_SECTOR=FirstSectorOfCluster;}



return NUMERO_DE_SECTOR;}
/*------------------------------------------------------------------*/








/*-----------------------------------------------ESTE ALGORITMO SE ENCARGA DE MAPEAR EL DIRECTORIO RAIZ (char Dir_Root[]=NOMBRE DEL ARCHIVO)-----------------------------------------------*/
unsigned int READ_Root_Dir_MEMORY_SD_MMC(uint32_t SIZE_SECTOR,uint32_t NUM_SECTORE,const char Dir_Root[]){



// 		if (NAMEP==0)
// 		{
// 			DDRD=(1<<DDD0);
// 			PORTD=(1<<PORTD0);
// 		}
//
FAT_32_16.PESO_FILE_BYTE=0x00000000;
unsigned int CLOUSTER=0x0000;


uint16_t NAMEP=0,PLO=0;


uint8_t READ_DATA_Root_dir_1[SIZE_SECTOR];/*AQUI GUARDAMOS EL PRIMER SECTOR DEL DIRECTORIO RAIZ A MAPEAR*/
uint8_t READ_DATA_Root_dir_2[SIZE_SECTOR];/*AQUI GUARDAMOS EL SECTOR DEL SIGUIENTE DIRECTORIO RAIZ A MAPEAR*/
char DATA_Root_dir[512];/*AQUI ALMACENAMOS EL DIRECTORIO DE [N*32 Bytes] QUE VAYAMOS LEYENDO*/

for (uint8_t SECUaE=0;SECUaE<11;SECUaE++){

TYU[SECUaE]=Dir_Root[SECUaE];
}
VALID=0;
while (VALID<10){/*ESTE WHILE SE ENCARGA DE HACER EL CORRIDO DE CADA SECTOR QUE COMPONE EL DIRECTORIO RAIZ*/


uint8_t ARCHIVO_ENCONTRADO=0,CONTROL_DIRECTORIO=0;
NUM_SECTORE=NUM_SECTORE+VALID;


/*LEEMOS EL PRIMER SECTOR QUE CONTIENE LOS DATOS DEL DIRECTORIO RAIZ*/
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,((NUM_SECTORE*SIZE_SECTOR)>>16),(NUM_SECTORE*SIZE_SECTOR),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
PAUSE_FLUJO(2000,1,0,1);
for(uint16_t i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_Root_dir_1[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);



/*LA VARIABLE VALID APORTA CON UN CONTADOR DE 0 a N*/
Var1=0,Var2=0,R_N=0;






if (Var3>15){
Var1=Var3-15;
Var3=0;
}else{
Var1=0;
Var3=0;}





while(Var1<16){

Ord=0x40;


for(uint16_t i=0;i!=(512);i++){DATA_Root_dir[i]=0x00;}



for(uint16_t i=0;i!=(32);i++){
DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+32*Var1];}




if((DATA_Root_dir[11]==0x0f)&&(DATA_Root_dir[12]==0x00)){


Ord=DATA_Root_dir[0]-Ord+1;
Var3=Var1+(Ord);




if(Var3>15){
/*LEEMOS EL PRIMER SECTOR QUE CONTIENE LOS DATOS DEL DIRECTORIO RAIZ*/
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,(((NUM_SECTORE+1)*SIZE_SECTOR)>>16),((NUM_SECTORE+1)*SIZE_SECTOR),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
PAUSE_FLUJO(500,1,0,1);
for(uint16_t i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_Root_dir_2[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);




/*CONTROL_DIRECTORIO=1;*/
Var2=(15-Var1);

for(uint16_t i=0;i!=(32*Var2);i++){
DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+32*Var1];}

for(uint16_t i=0;i!=32*(Var3-15);i++){
DATA_Root_dir[i+(32*Var2)]=READ_DATA_Root_dir_2[i];}
Var1=Var3;

}



else{
if ((Var1>=0)&&(Var1<=15)){
//CONTROL_DIRECTORIO=0;
R_N=((Ord)*32);
for(uint16_t i=0;i!=(R_N);i++){DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+Var1*32];}
Var1=Var3;}}


// WRITE_MEMORY_SD_MMC(DATA_Root_dir,512,(100000+PLO));
// PLO++;



}





/*ESTE ELSE DE CONTROL SE ENCARGA DE----------------------------------------------- */
else{
if ((Var1>=0)&&(Var1<=15)){



for(int i=0;i!=(32);i++){
DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+32*Var1];}










/*AQUI OPTENEMOS EL CLUSTER DEL ARCHIVO QUE BUSCAMOS*/
NAMEP=0;
for(int i=0;i!=(11);i++){
if (DATA_Root_dir[i]==Dir_Root[i]){
NAMEP++;}}

if((NAMEP==11)){
ARCHIVO_ENCONTRADO=1;
Var1=15;
VALID=10;
/*sacamos los 4 bytes que nos dicen el peso del archivo*/
for(int luis=31;luis!=27;luis--){
FAT_32_16.PESO_FILE_BYTE=(FAT_32_16.PESO_FILE_BYTE<<8)|DATA_Root_dir[luis];}
PESO_FILE=FAT_32_16.PESO_FILE_BYTE/1024;
for(int luis=27;luis!=25;luis--){
CLOUSTER=(CLOUSTER<<8)|DATA_Root_dir[luis];}
}
/*AQUI OPTENEMOS EL CLUSTER DEL ARCHIVO QUE BUSCAMOS*/

Var1+=1;
}




}
/*ESTE ELSE DE CONTROL SE ENCARGA DE----------------------------------------------- */



}




VALID+=1;

if(ARCHIVO_ENCONTRADO==0){CLOUSTER=0;}
}




return	CLOUSTER;}
/*-----------------------------------------------ESTE ALGORITMO SE  ENCARGA DE MAPEAR EL DIRECTORIO RAIZ (char Dir_Root[]=NOMBRE DEL ARCHIVO)-----------------------------------------------*/












/*ESTA FUNCION SE ENCARGA DE LEER EL PRIMER SECTOR DE LA MEMORIA SD QUE CONTIENE LA MASTER BOOT RECORDS (MBR)*/

void READ_MBR(uint16_t SIZE_SECTOR){

uint8_t  READ_DATA_2[SIZE_SECTOR];
for(uint16_t i=0;i!=512;i++){
READ_DATA_2[i]=0x00;}
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,(0),(0),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
for(uint16_t i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_2[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0xEEAA);
PORTC^=(1<<PORTC0);



for (int i=0;i!=SIZE_SECTOR;i++){
/*NUMERO DE BYTE POR BLOQUE(SECTOR)*/
if(i==11){
for(int luis=12;luis!=10;luis--){
FAT_32_16.BPB_BytsPerSec=(FAT_32_16.BPB_BytsPerSec<<8)|READ_DATA_2[luis];}}
/*NUMERO DE BLOQUES(SECTOR) POR CLUSTER(UNIDAD DE ASIGNASION)*/
if(i==13){
BPB_SecPerClus=READ_DATA_2[13];
if(BPB_SecPerClus==0x04){}}
/*NUMERO DE BLOQUES RESERVADOS*/
if(i==14){
for(int luis=15;luis!=13;luis--){
BPB_RsvdSecCnt=(BPB_RsvdSecCnt<<8)|READ_DATA_2[luis];}
if(BPB_RsvdSecCnt==0x0001){}}
/*NUMERO DE TABLAS DE ASIGNACION DE ARCHIVOS(FATs)*/
if((i==16)){
FAT_32_16.BPB_NumFATs=READ_DATA_2[16];
if(FAT_32_16.BPB_NumFATs==0x02){}}
/*NUMERO DE ENTRADAS DEL DIRECTORIO RAIZ*/
if(i==17){
for(int luis=18;luis!=16;luis--){
BPB_RootEntCnt=(BPB_RootEntCnt<<8)|READ_DATA_2[luis];}
if(BPB_RootEntCnt==0x0200){}}
/*NUMERO DE TOTAL DE BLOQUES(SECTORES) EN TODO EL DISCO FTA16*/
if(i==19){
for(int luis=20;luis!=18;luis--){
BPB_TotSec16=(BPB_TotSec16<<8)|READ_DATA_2[luis];}}
/*DESCRIPTOR DE MEDIOS*/
if((i==21)){
BPB_Media=READ_DATA_2[21];
if(BPB_Media==0xf8){}}
/*NUMERO DE BLOQUES OCUPADOS POR UNA FAT*/
if(i==22){
for(int luis=23;luis!=21;luis--){
BPB_FATz16=(BPB_FATz16<<8)|READ_DATA_2[luis];}
if(BPB_FATz16==0x0000){
for(int luis=39;luis!=35;luis--){
BPB_FATz32=(BPB_FATz32<<8)|READ_DATA_2[luis];}}}
/*NUMERO DE TOTAL DE BLOQUES(SECTORES) EN TODO EL DISCO FTA32*/
if((i==32)){
for(int luis=35;luis!=31;luis--){
BPB_TotSec32=(BPB_TotSec32<<8)|READ_DATA_2[luis];}
if(BPB_TotSec32==0x0003e5e0){}}
/*NUMERO DE SERIE DEL VOLUMEN*/
if((i==39)){
for(int luis=42;luis!=38;luis--){
BS_VolID=(BS_VolID<<8)|READ_DATA_2[luis];}
if(BS_VolID==0xf8){}}
if((i==44)){
for(int luis=47;luis!=43;luis--){
BPB_RootClu=(BPB_RootClu<<8)|READ_DATA_2[luis];}
if(BPB_RootClu==0xf8){}}
/*FIRMA DEL BLOQUE DE ARRANQUE*/
if((i==510)){
for(int luis=511;luis!=509;luis--){
F_MBR=(F_MBR<<8)|READ_DATA_2[luis];}}}
/*SECTORES OCUPADOS POR EL DIRECTORIO RAIZ*/
RootDirSectors=((BPB_RootEntCnt*32)+(FAT_32_16.BPB_BytsPerSec-1))/FAT_32_16.BPB_BytsPerSec;
/*-------------------------------------------------*/
if(BPB_FATz16==0){FATSz=BPB_FATz32;}
else{FATSz=BPB_FATz16;}
if(BPB_TotSec16==0){TotSec = BPB_TotSec32;}
else{TotSec=BPB_TotSec16;}
/*SECTORES TOTALES QUE CONPONEN LA UNIDAD DE ALMACENAMIENTO SD*/
DskSize=TotSec;
/*SECTORES TOTALES QUE CONPONEN LA REGION DE SOLO DATOS DE LA UNIDAD DE ALMACENAMIENTO SD*/
DataSec=DskSize-(BPB_RsvdSecCnt+(FAT_32_16.BPB_NumFATs*FATSz)+RootDirSectors);
/*NUMERO DE UNIDADES DE ASIGNACION(CLUSTER) QUE CONTIENE LA UIDAD DE ALMACENAMIENTO SD*/
CountofClusters=DataSec/BPB_SecPerClus;
/*CONDICIONES PARA ELEGIR EL TIPO DE FAT EN FUNCION DEL NUMERO DE UIDADES DE ASIGNACION(CLUSTER)*/
if(CountofClusters<4084){/*Volume is FAT12*/TYPPE_FAT=12;}else{
if(CountofClusters<65606){/*Volume is FAT16*/TYPPE_FAT=16;}
else {/*Volume is FAT32*/TYPPE_FAT=32;}}
/*SECTORES OCUPADOS POR LAS FAT Y LA REGION DE DATOS*/
FAT_AND_DATA_REGION=DskSize-(BPB_RsvdSecCnt+RootDirSectors-1);
TmpVal2=(256*BPB_SecPerClus)+FAT_32_16.BPB_NumFATs/*+BPB_RootClu*/;
SIZE_FAT=(FAT_AND_DATA_REGION+(TmpVal2-1))/TmpVal2;
//float OPO=0;
if(TYPPE_FAT==32){
//OPO=(float)TmpVal2*0.5-BPB_RootClu;
TmpVal2=TmpVal2*0.5/**/;}
FATSz = ((FAT_AND_DATA_REGION + (TmpVal2 - 1)) / TmpVal2);
/*---------------------------------------------------------------------------------------------*/
if(TYPPE_FAT==32){
BPB_FATz16=0;
BPB_FATz32=FATSz;
FirstRootDirSecNum=BPB_RsvdSecCnt+(FAT_32_16.BPB_NumFATs*BPB_FATz32)-BPB_RootClu;
FirstDataSector=(uint32_t)BPB_RsvdSecCnt+(FAT_32_16.BPB_NumFATs*FATSz)+(uint32_t)RootDirSectors-BPB_RootClu;
}else{BPB_FATz16=FATSz;
FirstRootDirSecNum=BPB_RsvdSecCnt+(FAT_32_16.BPB_NumFATs*BPB_FATz16);
FirstDataSector=(uint32_t)BPB_RsvdSecCnt+(FAT_32_16.BPB_NumFATs*FATSz)+(uint32_t)RootDirSectors;}

//CONVER_INT_CHAR_ILI9431(77,0,0,0x00,0xffff);

}/*ESTA FUNCION SE ENCARGA DE LEER EL PRIMER SECTOR DE LA MEMORIA SD QUE CONTIENE LA MASTER BOOT RECORDS (MBR)*/





#endif