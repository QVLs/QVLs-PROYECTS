

/*CUSTOM_CMD_SET_SD_MMC(0x58,0x00,0x00,0xff);
WRITE_MEMORY_SD_MMC(HOLA,512,0,0);*/


/*CMD18 LEER BLOQUE MULTIPLE
CUSTOM_CMD_SET_SD_MMC(0x18,0x00,0x00,0xff);*/

/*CMD24 ESCRIBIR BLOQUE UNICO
CUSTOM_CMD_SET_SD_MMC(0x58,0x00,0x00,0xff);*/


/*CMD25 ESCRIBIR BLOCK MULTIPLE
CUSTOM_CMD_SET_SD_MMC(0x19,0x00,0x00,0xff);*/

/*CMD28 ACTIVA PROTECCION CONTRA ESCRITURA
CUSTOM_CMD_SET_SD_MMC(0x19,0x00,0x00,0xff);*/

/*CMD29 DESACTIVA LA PROTECCION CONTRA ESCRITURA
CUSTOM_CMD_SET_SD_MMC(0x19,0x00,0x00,0xff);*/

/*CMD30 PIDE DETALLES DEL ESTADO DE PROTECCION CONTRA ESCRITURA
CUSTOM_CMD_SET_SD_MMC(0x19,0x00,0x00,0xff);*/

/*CMD32 ESTABLECE LA DIRECION DEL PRIMER BLOQUE QUE SE BORRARA
CUSTOM_CMD_SET_SD_MMC(0x19,0x00,0x00,0xff);*/

/*CMD33 ESTABLECE LA DIRECION DEL ULTIMO BLOQUE QUE SE BORRARA
CUSTOM_CMD_SET_SD_MMC(0x19,0x00,0x00,0xff);*/

/*CMD38 BORRA TODOS LOS BLOQUES SELECCIONADOS PREVIAMNTE
CUSTOM_CMD_SET_SD_MMC(0x19,0x00,0x00,0xff);*/


/*CMD17 LEER BLOQUE UNICO
CUSTOM_CMD_SET_SD_MMC(0x11,0x00,0x00,0xff);*/



#ifndef  SD_QVL_LIBRARY
#define SD_QVL_LIBRARY
#include <avr/io.h>
#include "LCD_LIBRERIA_QVL.h"
#include "LIBRERIA_DELAY_QVL.h"
#include "LIBRERIA_SPI_QVL.h"
#include "LIBRERIA_SPI_LCD_QVL.h"
#include <avr/pgmspace.h>


/*
static struct FAT{

}FAT_32_16;*/
static uint8_t BPB_Media=0,BPB_SecPerClus=0,PESO_FILE=0;
static uint16_t RootDirSectors=0,F_MBR,FAT16ClusEntryVal,FirstSectorOfCluster=0,BPB_FATz16=0,BPB_TotSec16=0,BPB_RootEntCnt=0,BPB_RsvdSecCnt=0/*,FirstSectorofCluster=0*/;
static uint32_t BS_VolID=0,BPB_RootClu=0,BPB_FATz32=0,BPB_TotSec32=0,DskSize=0,CountofClusters=0,DataSec=0,TotSec=0,FATSz=0;
static uint32_t PESO_FILE_BYTE=0;
static uint8_t BPB_NumFATs=0;
static uint16_t BPB_BytsPerSec=0;

static int32_t FAT_AND_DATA_REGION=0,TmpVal2=0,FirstRootDirSecNum=0,FirstDataSector=0,
TYPPE_FAT=0,SIZE_FAT=0, FAT_Offset=0,/*NUMERO_CLUSTER_VALIDO=78,*/ThisFATSecNum=0,ThisFATEntOffset=0,SectorNumber=0,FAT32ClusEntryVal=0;
uint16_t CLOUSTER_=0x0000;

// void READ_MEMORY_SD_INFO_FILE(char[]);
// void _MEMORY_SD_INFO();

void READ_MBR(uint16_t);
unsigned int READ_Root_Dir_MEMORY_SD_MMC(uint32_t,uint32_t,const char[]);
/*PROTOTIPOS DE FUNCIONES*/
/*ESTA FUNCION PERMITE OBTENER LA INFORMACION DE LA PRIMERA PARTICION DEL MASTER BOOT RECORDS*/
unsigned int SEARCH_CLUSTER_FILE(uint16_t,const char[]);

/*ESTA FUNCION SIRBE DE BASE PARA CREAR UNA FUNCION QUE PERMITA OBENER LA INFORMACION DEL SECTOR 0 DE LA MBR*/
void READ_MEMORY_SD_MMC_INFO(const uint16_t);

/*ESTA FUNCION SIRBE PARA LA ESCRITURA DE UN SECTOR ARGUMENTO (VECTOR_DE_DATOS_DEL_SECTOR[512],TAMAÑO_DEL_SECTOR=512,UBICACION_DEL_SECTOR_AESCRIBIR=X)*/
void WRITE_MEMORY_SD_MMC(uint8_t[],uint16_t,uint32_t);

/*ESTA FUNCION PARA LEER CUALQUIER SETOR INDIVIDUAL DE LA MEMORIA SD SUS SON PARAMETROS (TAMAÑO_DEL_SECTOR,UBICACION_DEL_SECTOR_A_ESCRIBIR)*/
void READ_MEMORY_SD_MMC(uint16_t,uint32_t);

/*ESTA FUNCION ENVIA EL COMANDO DE INICIALIZACION A LA TARJETA SD*/
void INT_SD_MMC(void);

/*ESTA FUNCION ES INPORTANTE YA QUE LO QUE HACE ES ENVIARLE MAS DE 80 PULSOS DE RELOJ A LA TARJETA SD CON EL OBJETIVO DE QUE ESTA PUED INICIAR EL MODO SPI*/
void RESET_SD_MMC(void);

/*ESTA FUNCION SE ENCARGA DE ESTABLECCER EL TAMAÑO QUE TENDRA CADA SECTOR EN LA TARJETA SD POR DEFECTO ESTE ES DE 512 bytes*/
void BLOCK_MEMORY_SET_SD_MMC(int16_t,int16_t);

/*ESTA FUNCION ME PERMITE ENVIAR COMANDOS, ESTABECIENDO COMO PARAMETROS VALORES ENTEROS (COMANDO_SPI,ARGUMENTO_MSB,ARGUMENTO_LSB,CHECKSUM) */
uint16_t CUSTOM_CMD_SET_SD_MMC(uint8_t, uint16_t,uint16_t,uint8_t);

/*ESTA FUNCION ES IGUAL QUE "CUSTOM_CMD_SET_SD_MMC();" SOLO QUE EN ESTA NO SE ACTIVA EL PIN SELET SLAVE*/
void CUSTOM_CMD_SET_SD(uint8_t,uint16_t,uint16_t,uint8_t,uint8_t);

/*ESTA FUNCION PERMITE LEER UN SECTOR DE LA TARJETA SD Y COPIARLO EN OTRO SECTOR QUE EL USUARIO QUIERA PREBIAMENTE HABIENDO ELEGIDO EN 1 EL TERCER PARAMETRO */
void READ_AND_COPY_MEMORY_SD_MMC(uint16_t,uint32_t,int,uint32_t);
/*PROTOTIPOS DE FUNCIONES*/


/*ESTA FUNCION ES DE  SUMA IMPORTANCIA YA QUE PERMITE ARRANCARR LA TARJETA SD EN MODO SPI GENERANDO
UN TREN DE PULSOS IMPAR EN EL CLOCK DE LA SD PARA QUE ESTA SE ACTIVE EN MODO SPI*/
void RESET_SD_MMC(void){
for (int i=0;i!=1000;i++){PAUSE_FLUJO(0,1,0,1);PORTC^=(1<<PORTC3);
SPI_MASTER_TRANSMITION_16_BITS(0x0000);}




}




void INT_SD_MMC(void){
RESET_SD_MMC();
CUSTOM_CMD_SET_SD_MMC(0x00,0x00,0x00,0x95);/*CMD0 INICIALISACION DE LA SD/MMC*/
CUSTOM_CMD_SET_SD_MMC(0x01,0x00,0x00,0xff);/*CMD1 RESET DEL SOFTWRE DE LA SD/MMC*/
CUSTOM_CMD_SET_SD_MMC(0x10,0x00,0x200,0xff);/*CMD10 SET THE SIZE BLOCK*/READ_MBR(512);}

/*------------------------------------------------------------------*/
void BLOCK_MEMORY_SET_SD_MMC(int16_t CMD_ARGUMENT_MSB,int16_t CMD_ARGUMENT_LSB){
/*CMD0*//*50 00 000 00 08 ff*/
PORTC^=(1<<PORTC0);
/*CONFIGURACION DEL TAMAÑO DEL BLOQUE DE MEMORIA QUE SE USARA PARA GUARDAR DATOS VALOR ES DE DEFAULT 512 bytes*/
CUSTOM_CMD_SET_SD(10,0,512,0xff,0x00);
PORTC^=(1<<PORTC0);}

/*------------------------------------------------------------------*/
/*FUNCION DE SUMA IMPORTANCIA QUE SIRVE PARA ENVIAR COMANDOS A LA TARJETA SD TIENE COMO PARAMETROS
CMDX(ES PARA INDICARLE QUE ACCION VA A REALIZAR)1Byte
CMD_ARGUMENT_MSB(EL ARGUMENTO MAS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CMD_ARGUMENT_LSB(EL ARGUMENTO MENOS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CRC(SE LE ENVIA LA SUMA DE VERIFICACION DE LOS DATOS QUE SE ESTAN ENVIADO)1Byte
CON PINES DE SELET SLAVE INCORPORADOS EN LA FUNCION*/
uint16_t CUSTOM_CMD_SET_SD_MMC(uint8_t CMDX,uint16_t CMD_ARGUMENT_MSB,uint16_t CMD_ARGUMENT_LSB,uint8_t CRC){
/*CMD0*//*87 xx xx xx xx ff*/
uint8_t ERROR_SD=0;
PORTC^=(1<<PORTC0);
/*CONFIGURACION DEL TAMAÑO DEL BLOQUE DE MEMORIA QUE SE USARA PARA GUARDAR DATOS VALOR ES DE DEFAULT 512 bytes*/
CMDX=(CMDX);
CMDX=(CMDX|0b01000000);/*AQUI AJUSTAMOS EL BIT DE STAR DE DEL Byte DE COMANDO QUE SE LE ENVIE A LA SD*/
SPI_MASTER_TRANSMITION_8_BITS(CMDX);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_MSB);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_LSB);
SPI_MASTER_TRANSMITION_8_BITS(CRC);
ERROR_SD=SPI_RECEIVE_MODE_MASTER_16BITS_();
PORTC^=(1<<PORTC0);
return ERROR_SD;}




/*FUNCION DE SUMA IMPORTANCIA QUE SIRVE PARA ENVIAR COMANDOS A LA TARJETA SD TIENE COMO PARAMETROS
CMDX(ES PARA INDICARLE QUE ACCION VA A REALIZAR)1Byte
CMD_ARGUMENT_MSB(EL ARGUMENTO MAS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CMD_ARGUMENT_LSB(EL ARGUMENTO MENOS SIGNIFICATIVO, EN CASO DE QUE SE QUIERA ESTABLECER EL TAMAÑO DEL BLOQUE POR EJEMPLO)2Byte
CRC(SE LE ENVIA LA SUMA DE VERIFICACION DE LOS DATOS QUE SE ESTAN ENVIADO)1Byte
SIN PINES DE SELET SLAVE INCORPORADOS EN LA FUNCION*/
void CUSTOM_CMD_SET_SD(uint8_t CMDX,uint16_t CMD_ARGUMENT_MSB,uint16_t CMD_ARGUMENT_LSB,uint8_t CRC,uint8_t ERROR){
/*CMD0*/
/*87 xx xx xx xx ff*/
/*CONFIGURACION DEL TAMAÑO DEL BLOQUE DE MEMORIA QUE SE USARA PARA GUARDAR DATOS VALOR ES DE DEFAULT 512 bytes*/
CMDX=(CMDX);
CMDX=(CMDX|0b01000000);
SPI_MASTER_TRANSMITION_8_BITS(CMDX);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_MSB);
SPI_MASTER_TRANSMITION_16_BITS(CMD_ARGUMENT_LSB);
SPI_MASTER_TRANSMITION_8_BITS(CRC);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=ERROR);}



/*ESTA FUNCION ESCRIBE EN LA MEMORIA SD*/
void WRITE_MEMORY_SD_MMC(uint8_t DATA[],uint16_t SIZE_SECTOR,uint32_t NUM_SECTORE){
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(24,((NUM_SECTORE*SIZE_SECTOR)>>16),(NUM_SECTORE*SIZE_SECTOR),0xff,0x00);
SPI_MASTER_TRANSMITION_8_BITS(0xfe);
for(int i=0;i!=SIZE_SECTOR;i++){
SPI_MASTER_TRANSMITION_8_BITS(DATA[i]);}
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0x05);
PORTC^=(1<<PORTC0);}



/*ESTA FUNCION LEE UN SECTOR DE 512 Bytes EN LA MEMORIA SD Y COPIA EL CONTENIDO COPIADO EN OTRO SECTOR DE LA MEMORIA SD*/
void READ_AND_COPY_MEMORY_SD_MMC(uint16_t SIZE_SECTOR,uint32_t NUM_SECTORE,int COPY,uint32_t NUM_SECTORE_1){
uint8_t READ_DATA_0[SIZE_SECTOR];
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,((NUM_SECTORE*SIZE_SECTOR)>>16),(NUM_SECTORE*SIZE_SECTOR),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
for(int i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_0[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);
if(COPY){WRITE_MEMORY_SD_MMC(READ_DATA_0,SIZE_SECTOR,NUM_SECTORE_1);}}




/*ESTA FUNCION LEE UN SECTOR DE 512 Bytes EN LA MEMORIA SD*/
void READ_MEMORY_SD_MMC(uint16_t SIZE_SECTOR,uint32_t NUM_SECTORE){
	
uint8_t READ_DATA_1[SIZE_SECTOR];
// for(int i=0;i!=(SIZE_SECTOR);i++){
// READ_DATA_1[i]=0;}

PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,((NUM_SECTORE*SIZE_SECTOR)>>16),(NUM_SECTORE*SIZE_SECTOR),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
PAUSE_FLUJO(2000,1,0,1);
for(int i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_1[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);}


/*ESTA FUNCION SIRVE PARA BUSCAR EL SECTOR INICAL EN EL QUE SE ENCUENTRAN LOS DATOS DE ALGUN ARCHIVO DE LA MEMORIA SD*/
unsigned int SEARCH_CLUSTER_FILE(uint16_t SIZE_SECTOR_2,const char String_4[]){char NOMBRE_DEL_ARCHIVO[11];
for(int i=0;i!=11;i++){
NOMBRE_DEL_ARCHIVO[i]=0x20;}
int i=0,EXTENCION_DEL_FILE=0;
while(i!=8){
if(String_4[i]=='.'){EXTENCION_DEL_FILE=i;i=8;}
else{NOMBRE_DEL_ARCHIVO[i]=String_4[i];
i++;}}
for(int i=8;i!=11;i++){EXTENCION_DEL_FILE++;
NOMBRE_DEL_ARCHIVO[i]=String_4[EXTENCION_DEL_FILE];}if(BPB_FATz16==0){FATSz=BPB_FATz32;}
else{FATSz=BPB_FATz16;}
	
if(TYPPE_FAT==16){FAT_Offset=READ_Root_Dir_MEMORY_SD_MMC(512,FirstRootDirSecNum,NOMBRE_DEL_ARCHIVO)*2;}else{if(TYPPE_FAT==32){FAT_Offset=READ_Root_Dir_MEMORY_SD_MMC(512,FirstRootDirSecNum,NOMBRE_DEL_ARCHIVO)*4;}}ThisFATSecNum=BPB_RsvdSecCnt+(FAT_Offset/BPB_BytsPerSec);ThisFATEntOffset=(FAT_Offset%BPB_BytsPerSec);SectorNumber=(BPB_NumFATs*FATSz)+ThisFATSecNum;
FAT16ClusEntryVal=0;



unsigned int NUMERO_DE_SECTOR=0;
uint8_t READ_FAT[SIZE_SECTOR_2];


PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,((ThisFATSecNum*SIZE_SECTOR_2)>>16),(ThisFATSecNum*SIZE_SECTOR_2),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
PAUSE_FLUJO(2000,1,0,1);
for(int i=0;i!=(SIZE_SECTOR_2);i++){
READ_FAT[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);



uint8_t FAT_L=0;

/*CON ESTAS CONDICIONES SE OPTIENE EL VALOR DE LA POSICION EN DECIMAL DE LA ENTRADA FAT CORRESPONDIENTE AL CLUSTER DESEADO FAT_Offset*/if(TYPPE_FAT==16){FAT_L=3;FAT16ClusEntryVal=READ_FAT[ThisFATEntOffset+1];FAT16ClusEntryVal=(FAT16ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset];FirstSectorOfCluster=((FAT16ClusEntryVal-FAT_L)*BPB_SecPerClus)+FirstDataSector;}else{FAT_L=3;FAT32ClusEntryVal=READ_FAT[ThisFATEntOffset+3];FAT32ClusEntryVal=(FAT32ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset+2];
FAT32ClusEntryVal=(FAT32ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset+1];
FAT32ClusEntryVal=(FAT32ClusEntryVal<<8)|READ_FAT[ThisFATEntOffset];
FirstSectorOfCluster=((FAT32ClusEntryVal-FAT_L)*BPB_SecPerClus)+FirstDataSector;}



/*INDICA EL SECTOR INICIAL DONDE SE ALMACENAN LOS DATOS CORRESPONDIENTE A UN CLUSTER ESPESIFICO*///FirstSectorOfCluster=((FAT16ClusEntryVal-FAT_L)*BPB_SecPerClus)+FirstDataSector;
 if(FAT_Offset==0){NUMERO_DE_SECTOR=FAT_Offset;}
else{NUMERO_DE_SECTOR=FirstSectorOfCluster;}



return NUMERO_DE_SECTOR;}
/*------------------------------------------------------------------*/








/*-----------------------------------------------ESTE ALGORITMO SE ENCARGA DE MAPEAR EL DIRECTORIO RAIZ (char Dir_Root[]=NOMBRE DEL ARCHIVO)-----------------------------------------------*/
unsigned int READ_Root_Dir_MEMORY_SD_MMC(uint32_t SIZE_SECTOR_1,uint32_t NUM_SECTORE_1,const char Dir_Root[]){
uint8_t READ_DATA_Root_dir_1[512];/*AQUI GUARDAMOS EL PRIMER SECTOR DEL DIRECTORIO RAIZ A MAPEAR*/
uint8_t READ_DATA_Root_dir_2[512];/*AQUI GUARDAMOS EL SECTOR DEL SIGUIENTE DIRECTORIO RAIZ A MAPEAR*/
CLOUSTER_=0x0000;
PESO_FILE_BYTE=0x00000000;
uint32_t NUM_SECTORE_L=0,NUM_SECTORE_H=NUM_SECTORE_1;
uint16_t Var1=0,Var2=0,Var3=0,Ord=0,R_N=0;
uint16_t NAMEP=0/*,PLO=0*/;
char DATA_Root_dir[512];/*AQUI ALMACENAMOS EL DIRECTORIO DE [N*32 Bytes] QUE VAYAMOS LEYENDO*/
uint32_t VALID=0;
const uint16_t CORRIDO_SECTOR_DIR=100;
while (VALID<CORRIDO_SECTOR_DIR){/*ESTE WHILE SE ENCARGA DE HACER EL CORRIDO DE CADA SECTOR QUE COMPONE EL DIRECTORIO RAIZ*/
uint8_t ARCHIVO_ENCONTRADO=0;


NUM_SECTORE_H=(NUM_SECTORE_H+VALID)*512;
NUM_SECTORE_L=(NUM_SECTORE_H);
NUM_SECTORE_H=(NUM_SECTORE_H>>16);


/*LEEMOS EL PRIMER SECTOR QUE CONTIENE LOS DATOS DEL DIRECTORIO RAIZ*/
//PAUSE_FLUJO(200,1,0,1);
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,(NUM_SECTORE_H),(NUM_SECTORE_L),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
for(uint16_t i=0;i!=(SIZE_SECTOR_1);i++){
READ_DATA_Root_dir_1[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);
//PAUSE_FLUJO(200,1,0,1);

Var2=0;
R_N=0;

if (Var3>16){
Var1=Var3-16;
Var3=0;
}
else{
Var1=0;
Var3=0;
}


while(Var1<16){
	
Ord=0x40;

for(uint16_t i=0;i!=(512);i++){DATA_Root_dir[i]=0x00;}

for(uint16_t i=0;i!=(32);i++){DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+32*Var1];}

if((DATA_Root_dir[11]==0x0f)&&(DATA_Root_dir[12]==0x00)&&(DATA_Root_dir[0]>0x40)){

Ord=DATA_Root_dir[0]-Ord+1;

Var3=Var1+(Ord);

if(Var3>16){
	
	
/*LEEMOS EL PRIMER SECTOR QUE CONTIENE LOS DATOS DEL DIRECTORIO RAIZ*/
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,(((NUM_SECTORE_1+1)*SIZE_SECTOR_1)>>16),((NUM_SECTORE_1+1)*SIZE_SECTOR_1),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
for(uint16_t i=0;i!=(SIZE_SECTOR_1);i++){
READ_DATA_Root_dir_2[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0x1100);
PORTC^=(1<<PORTC0);
//PAUSE_FLUJO(200,1,0,1);



/*CONTROL_DIRECTORIO=1;*/
Var2=(16-Var1);

for(uint16_t i=0;i!=(32*Var2);i++){
DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+32*Var1];}

for(uint16_t i=0;i!=32*(Var3-16);i++){
DATA_Root_dir[i+(32*Var2)]=READ_DATA_Root_dir_2[i];}
Var1=Var3;}

else{
if ((Var1>=0)&&(Var1<=15)){
//CONTROL_DIRECTORIO=0;
R_N=((Ord)*32);
// PORTD^=(1<<PORTD0);
for(uint16_t i=0;i!=(R_N);i++){DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+Var1*32];}
Var1=Var3;}}

}
/*ESTE ELSE DE CONTROL SE ENCARGA DE----------------------------------------------- */
else{
if((Var1>=0)&&(Var1<=15)){

for(int i=0;i!=(32);i++){
DATA_Root_dir[i]=READ_DATA_Root_dir_1[i+32*Var1];}

/*AQUI OPTENEMOS EL CLUSTER DEL ARCHIVO QUE BUSCAMOS*/

for(int i=0;i!=(11);i++){
if (DATA_Root_dir[i]==Dir_Root[i]){
NAMEP++;}}


Var1+=1;


if((NAMEP==11)){
	

ARCHIVO_ENCONTRADO=1;
Var1=16;
VALID=CORRIDO_SECTOR_DIR;
/*sacamos los 4 bytes que nos dicen el peso del archivo*/
for(int luis=31;luis!=27;luis--){
PESO_FILE_BYTE=(PESO_FILE_BYTE<<8)|DATA_Root_dir[luis];}
PESO_FILE=PESO_FILE_BYTE/1024;
for(int luis=27;luis!=25;luis--){
CLOUSTER_=(CLOUSTER_<<8)|DATA_Root_dir[luis];}}
/*AQUI OPTENEMOS EL CLUSTER DEL ARCHIVO QUE BUSCAMOS*/}

NAMEP=0;
}
/*ESTE ELSE DE CONTROL SE ENCARGA DE----------------------------------------------- */
// 
// WRITE_MEMORY_SD_MMC(DATA_Root_dir,512,(210000+PLO));
// PLO++;

}

VALID+=1;




if(ARCHIVO_ENCONTRADO==0){CLOUSTER_=0;}
}




return	CLOUSTER_;}
/*-----------------------------------------------ESTE ALGORITMO SE  ENCARGA DE MAPEAR EL DIRECTORIO RAIZ (char Dir_Root[]=NOMBRE DEL ARCHIVO)-----------------------------------------------*/












/*ESTA FUNCION SE ENCARGA DE LEER EL PRIMER SECTOR DE LA MEMORIA SD QUE CONTIENE LA MASTER BOOT RECORDS (MBR)*/

void READ_MBR(uint16_t SIZE_SECTOR){

uint8_t  READ_DATA_2[SIZE_SECTOR];
for(uint16_t i=0;i!=512;i++){
READ_DATA_2[i]=0x00;}
PORTC^=(1<<PORTC0);
CUSTOM_CMD_SET_SD(17,(0),(0),0xff,0x00);
do {} while (SPI_RECEIVE_MODE_MASTER_()!=0xfe);
for(uint16_t i=0;i!=(SIZE_SECTOR);i++){
READ_DATA_2[i]=SPI_RECEIVE_MODE_MASTER_();}
SPI_MASTER_TRANSMITION_16_BITS(0xEEAA);
PORTC^=(1<<PORTC0);



for (int i=0;i!=SIZE_SECTOR;i++){
/*NUMERO DE BYTE POR BLOQUE(SECTOR)*/
if(i==11){
for(int luis=12;luis!=10;luis--){
BPB_BytsPerSec=(BPB_BytsPerSec<<8)|READ_DATA_2[luis];}}
/*NUMERO DE BLOQUES(SECTOR) POR CLUSTER(UNIDAD DE ASIGNASION)*/
if(i==13){
BPB_SecPerClus=READ_DATA_2[13];
if(BPB_SecPerClus==0x04){}}
/*NUMERO DE BLOQUES RESERVADOS*/
if(i==14){
for(int luis=15;luis!=13;luis--){
BPB_RsvdSecCnt=(BPB_RsvdSecCnt<<8)|READ_DATA_2[luis];}
if(BPB_RsvdSecCnt==0x0001){}}
/*NUMERO DE TABLAS DE ASIGNACION DE ARCHIVOS(FATs)*/
if((i==16)){
BPB_NumFATs=READ_DATA_2[16];
if(BPB_NumFATs==0x02){}}
/*NUMERO DE ENTRADAS DEL DIRECTORIO RAIZ*/
if(i==17){
for(int luis=18;luis!=16;luis--){
BPB_RootEntCnt=(BPB_RootEntCnt<<8)|READ_DATA_2[luis];}
if(BPB_RootEntCnt==0x0200){}}
/*NUMERO DE TOTAL DE BLOQUES(SECTORES) EN TODO EL DISCO FTA16*/
if(i==19){
for(int luis=20;luis!=18;luis--){
BPB_TotSec16=(BPB_TotSec16<<8)|READ_DATA_2[luis];}}
/*DESCRIPTOR DE MEDIOS*/
if((i==21)){
BPB_Media=READ_DATA_2[21];
if(BPB_Media==0xf8){}}
/*NUMERO DE BLOQUES OCUPADOS POR UNA FAT*/
if(i==22){
for(int luis=23;luis!=21;luis--){
BPB_FATz16=(BPB_FATz16<<8)|READ_DATA_2[luis];}
if(BPB_FATz16==0x0000){
for(int luis=39;luis!=35;luis--){
BPB_FATz32=(BPB_FATz32<<8)|READ_DATA_2[luis];}}}
/*NUMERO DE TOTAL DE BLOQUES(SECTORES) EN TODO EL DISCO FTA32*/
if((i==32)){
for(int luis=35;luis!=31;luis--){
BPB_TotSec32=(BPB_TotSec32<<8)|READ_DATA_2[luis];}
if(BPB_TotSec32==0x0003e5e0){}}
/*NUMERO DE SERIE DEL VOLUMEN*/
if((i==39)){
for(int luis=42;luis!=38;luis--){
BS_VolID=(BS_VolID<<8)|READ_DATA_2[luis];}
if(BS_VolID==0xf8){}}
if((i==44)){
for(int luis=47;luis!=43;luis--){
BPB_RootClu=(BPB_RootClu<<8)|READ_DATA_2[luis];}
if(BPB_RootClu==0xf8){}}
/*FIRMA DEL BLOQUE DE ARRANQUE*/
if((i==510)){
for(int luis=511;luis!=509;luis--){
F_MBR=(F_MBR<<8)|READ_DATA_2[luis];}}}
/*SECTORES OCUPADOS POR EL DIRECTORIO RAIZ*/
RootDirSectors=((BPB_RootEntCnt*32)+(BPB_BytsPerSec-1))/BPB_BytsPerSec;
/*-------------------------------------------------*/
if(BPB_FATz16==0){FATSz=BPB_FATz32;}
else{FATSz=BPB_FATz16;}
if(BPB_TotSec16==0){TotSec = BPB_TotSec32;}
else{TotSec=BPB_TotSec16;}
/*SECTORES TOTALES QUE CONPONEN LA UNIDAD DE ALMACENAMIENTO SD*/
DskSize=TotSec;
/*SECTORES TOTALES QUE CONPONEN LA REGION DE SOLO DATOS DE LA UNIDAD DE ALMACENAMIENTO SD*/
DataSec=DskSize-(BPB_RsvdSecCnt+(BPB_NumFATs*FATSz)+RootDirSectors);
/*NUMERO DE UNIDADES DE ASIGNACION(CLUSTER) QUE CONTIENE LA UIDAD DE ALMACENAMIENTO SD*/
CountofClusters=DataSec/BPB_SecPerClus;
/*CONDICIONES PARA ELEGIR EL TIPO DE FAT EN FUNCION DEL NUMERO DE UIDADES DE ASIGNACION(CLUSTER)*/
if(CountofClusters<4084){/*Volume is FAT12*/TYPPE_FAT=12;}else{
if(CountofClusters<65606){/*Volume is FAT16*/TYPPE_FAT=16;}
else {/*Volume is FAT32*/TYPPE_FAT=32;}}
/*SECTORES OCUPADOS POR LAS FAT Y LA REGION DE DATOS*/
FAT_AND_DATA_REGION=DskSize-(BPB_RsvdSecCnt+RootDirSectors-1);
TmpVal2=(256*BPB_SecPerClus)+BPB_NumFATs/*+BPB_RootClu*/;
SIZE_FAT=(FAT_AND_DATA_REGION+(TmpVal2-1))/TmpVal2;
//float OPO=0;
if(TYPPE_FAT==32){
//OPO=(float)TmpVal2*0.5-BPB_RootClu;
TmpVal2=TmpVal2*0.5/**/;}
FATSz = ((FAT_AND_DATA_REGION + (TmpVal2 - 1)) / TmpVal2);
/*---------------------------------------------------------------------------------------------*/
if(TYPPE_FAT==32){
BPB_FATz16=0;
BPB_FATz32=FATSz;
FirstRootDirSecNum=BPB_RsvdSecCnt+(BPB_NumFATs*BPB_FATz32)-BPB_RootClu;
FirstDataSector=(uint32_t)BPB_RsvdSecCnt+(BPB_NumFATs*FATSz)+(uint32_t)RootDirSectors-BPB_RootClu;
}else{BPB_FATz16=FATSz;
FirstRootDirSecNum=BPB_RsvdSecCnt+(BPB_NumFATs*BPB_FATz16);
FirstDataSector=(uint32_t)BPB_RsvdSecCnt+(BPB_NumFATs*FATSz)+(uint32_t)RootDirSectors;}



}/*ESTA FUNCION SE ENCARGA DE LEER EL PRIMER SECTOR DE LA MEMORIA SD QUE CONTIENE LA MASTER BOOT RECORDS (MBR)*/

#endif