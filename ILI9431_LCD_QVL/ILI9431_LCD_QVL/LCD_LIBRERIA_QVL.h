#ifndef LCD_LIBRARY_QVL
#define LCD_LIBRARY_QVL

#include "LIBRERIA_DELAY_QVL.h"
#include <avr/io.h>
/*#include <avr/delay.h>*/
#define  BIT_BF 1
#define  CURSOR_HOME 0x00
#define BLINK_CURSOR_ON 0x0f
#define  BLINK_CURSOR_OFF 0x0c
#define DESPLAZAMIENTO_PANTALLA 0x1f
#define DISPLAY_CLEAR 0x01
#define CLEAR_DIGIT ' '
#define DESPLAZAMIENTO_CURSOR 0x2f

#define PORT_X0 PORTD
#define PORT_X1 PORTD

#define DDR_X0 DDRD
#define DDR_X1 DDRD

#define D_4 PORTD0
#define D_5 PORTD1
#define D_6 PORTD2
#define D_7 PORTD3
#define R_W PORTD4
#define R_S PORTD5
#define E_NABLE PORTD6





/*CONTROL_REFERENCIA=1;ENTERO=0;NUEVO_ENTERO=0;CENTENA_0=1;CENTENA_1=0;CONTROL_REFERENCIA=1;*/
// int32_t ENTERO,NUEVO_ENTERO,CENTENA_0,CENTENA_1,CENTENA_2,RESTO,CONTROL_REFERENCIA,PLUS_10_100[20],NUM_VECTOR[10];
// int CONTROL_0,CONTROL_1,CONTROL_3;
int DESFASE=1;
int PUNTO;int i=0;
/*volatile */int PUNTO_0,PUNTO_1,PUNTO_2,PUNTO_3;
int NUMERO_VECTOR,NUMERO_REFERENCIAL,DOS,DOS_1,DOS_2,RESOLUCION;
/*char RESULTADO[]="TEH NUMBER IS \0";*/
char NUM_VECTOR_REFERENCIA_0[10]={'0','1','2','3','4','5','6','7','8','9'};
int32_t NUM_VECTOR_REFERENCIA_1[10]={0,1,2,3,4,5,6,7,8,9};

char CONTROL_DE_CIONCIDENCIAS[61]=
{'Q','W','E','R','T','Y','U','I','O','P',
'A','S','D','F','G','H','J','K','L','Z',
'X','C','V','B','N','M','q','w','e','r',
't','y','u','i','o','p','a','s','f','g',
'h','j','k','l','z','x','c','v','b','*',
'n','m',';','[',']','{','}'};

void BORRAR_DIGITO();
void LCD_STAR_READ();
void LCD_STAR();
void LCD_PRINT(char[], int, int);
void BUSY_FLAG(void);
void DESPLAZAMIENTO_DER(int);
void DESPLAZAMIENTO_DER_PANTALLA(int);
void CURSOR_INICIO();
void LCD_PRINT_NUMERO(const char[],  int, int);
void ESTABLECER_DIRECCION_CGRAM(char);
void LIMPIAR_PANTALLA();
void B_OFF();
void B_ON();
void CONVER_INT_CHAR(const float, int, int);
char ANALISIS_COMPROBADOR_DE_IGUALDAD_DE_DATOS(char,char);
char ANALISIS_COMPROBADOR_DE_IGUALDAD_DE_DATOS(char DATA_1,char DATA_2){
char *ANALISIS_REFE="YES";
if(DATA_2==DATA_1){ANALISIS_REFE="YES";}else{
ANALISIS_REFE="NOT";}
LCD_PRINT(ANALISIS_REFE,0,0);
PAUSE_FLUJO(400,1,0,1);
return '0';}

void SEND_DATA(unsigned char);
void SEND_DATA(unsigned char SEND_DATA_0){
int8_t LSB=0b00000000,MSB=0b00000000,DATA;
DATA=SEND_DATA_0;
LSB=DATA;
MSB|=(LSB>>4);
MSB|=0b00100000;
LSB|=0b00100000;
MSB&=0b00101111;
LSB&=0b00101111;
PORT_X0|=(1<<E_NABLE);
PORT_X1=MSB;
PORT_X0&=~(1<<E_NABLE);
PORT_X0|=(1<<E_NABLE);
PORT_X1=LSB;
PORT_X0&=~(1<<E_NABLE);
PORT_X1=0x00;
/*BUSY_FLAG();*/PAUSE_FLUJO(50,1,0,1);}

void SET_COMANDS(uint8_t);
void SET_COMANDS(uint8_t CMD){
int8_t LSB=0b00000000,MSB=0b00000000,DATA;
DATA=CMD;
LSB=DATA;
MSB|=(LSB>>4);
MSB&=0b00001111;
LSB&=0b00001111;
PORT_X0|=(1<<E_NABLE);
PORT_X1=MSB;
PORT_X0&=~(1<<E_NABLE);
PORT_X0|=(1<<E_NABLE);
PORT_X1=LSB;
PORT_X0&=~(1<<E_NABLE);
PORT_X1=0x00;
/*BUSY_FLAG();*/PAUSE_FLUJO(50,1,0,1);}

/*ESTA FUNCION SE ENCARGA DE ESPERAR QUE EL LCD PROCESE LA
INSTRUCCION QUE SE LE A ENVIADO HACER CUANDO LA TERMINE LA
BANDERA SE PONE EN CERO LO QUE INDICA QUE LA TERMINO DE
PROCSESAR LO QUE SE LE MANDO TERMINO */
void BUSY_FLAG(void){
int DATA;DATA=1;
PORT_X1|=(1<<D_7);
PORT_X1&=(0<<R_S);
while(DATA==(1<<D_7)){
PORT_X1|=(1<<R_W);
PORT_X0|=(1<<E_NABLE);
PORT_X0&=~(1<<E_NABLE);
PORT_X0|=(1<<E_NABLE);
if(D_7==BIT_BF){DATA=1;}else{DATA=0;}
PORT_X0&=~(1<<E_NABLE);
PORT_X1&=(0<<R_W);}}

/*ESTA INSTRUCCION SE ENCARGA DE DIRECIONAR EL
PUNTERO HACIA LAS UBICACION DE LA MEMORIA (GRAM) DEL LCD*/
void DESPLAZAMIENTO_POR_DIRECCIONES_CGRAM(char);
void DESPLAZAMIENTO_POR_DIRECCIONES_CGRAM(char ADDRESS){
char DATA;
DATA=0x40;
DATA|=ADDRESS;
SET_COMANDS(DATA);
/*_delay_ms(1);*/}

/*ESTA INSTRUCCION SE ENCARGA DE DIRECIONAR EL
PUNTERO HACIA LAS UBICACION DE LA MEMORIA (DRAM) DEL LCD
LA CUAL ES LA QUE SE PUEDE VER EL LCD EN OTRAS PALABRAS
PERMITE EL DESPLASAMIENTO DEL CURSOR POR LA PANTALLA*/
void POSICIONES_DIRECCIONES_DDRAM(char);
void POSICIONES_DIRECCIONES_DDRAM(char ADDRESS){
/*DESPLAZAMIENTO_POR_DIRECCIONES(0x14);*/
char DATA;
DATA=0x80;
DATA|=ADDRESS;
SET_COMANDS(DATA);
/*_delay_ms(1);*/}

/*ESTA FUNCION SE ENCARGA DE SELECIONAR LA UBICACION DE LA GRAM Y LUEGO ESCRIBE SOBRE ELLA EL CARACTER (8*5)BITS PERSONALIZADO DEL USUARIO*/
void CARACTERES_PERSONALIZADOS(char,unsigned char *CUSTOM_CARACTER);
void CARACTERES_PERSONALIZADOS(char ADDRES,unsigned char *CUSTOM_CARACTER){
unsigned char i=0;
DESPLAZAMIENTO_POR_DIRECCIONES_CGRAM(ADDRES*8);
for(i=0;i!=8;i++){
SEND_DATA(CUSTOM_CARACTER[i]);}}
//CORREGIR BUGS GRAVES
/*ESTA FUNCION SE ENCARGA DE CONVERTIR
CUALQUIER NUMERO EN UNA CADENA DE VALORES
TIPO CHAR QUE REPRESENTAN EL NUMERO CONVERTIDO*/

void CONVER_INT_CHAR(const float NUMERO_LUIS, int POS_X, int POS_Y){
uint16_t C[6]={1,10,100,1000,10000,65535};
char N[9]={'\0','\0','\0','\0','\0','\0','\0','\0','\0'};
uint16_t ENTERO=NUMERO_LUIS;
uint8_t DECIMAL=((float)(NUMERO_LUIS-ENTERO))*100;
uint8_t N_INTERACCIONES=0,CONTROL=1;
if(ENTERO>0xffff){
N[0]='N';N[1]='a';N[2]='N';
}else{

if (ENTERO==0){
N[CONTROL-1]=0;
N[CONTROL-1]=N[CONTROL-1]+48;
CONTROL++;
;}
if (ENTERO>0){
if(ENTERO>=10000&&ENTERO<=65500){N_INTERACCIONES=5;
}else{
if(ENTERO>=1000&&ENTERO<=9999){N_INTERACCIONES=4;
}else{
if(ENTERO>=100&&ENTERO<=999){N_INTERACCIONES=3;
}else{
if(ENTERO>=10&&ENTERO<=99){N_INTERACCIONES=2;
}else{
if(ENTERO>=1&&ENTERO<=9){N_INTERACCIONES=1;}}}}}

N_INTERACCIONES=N_INTERACCIONES+CONTROL;

while(CONTROL!=N_INTERACCIONES){
N[CONTROL-1]=(uint8_t)(ENTERO/C[N_INTERACCIONES-CONTROL-1]);
ENTERO=ENTERO-N[CONTROL-1]*C[N_INTERACCIONES-CONTROL-1];
N[CONTROL-1]=N[CONTROL-1]+48;
CONTROL++;}}


ENTERO=DECIMAL;
if (ENTERO>0)
{N[CONTROL-1]='.';
CONTROL++;
if(ENTERO>=10&&ENTERO<=99){N_INTERACCIONES=2;
N_INTERACCIONES=N_INTERACCIONES+CONTROL;
while(CONTROL!=N_INTERACCIONES){
N[CONTROL-1]=(uint8_t)(ENTERO/C[N_INTERACCIONES-CONTROL-1]);
ENTERO=ENTERO-N[CONTROL-1]*C[N_INTERACCIONES-CONTROL-1];
N[CONTROL-1]=N[CONTROL-1]+48;
CONTROL++;}
}else{
if(ENTERO>=1&&ENTERO<=9){N_INTERACCIONES=1;
N_INTERACCIONES=N_INTERACCIONES+CONTROL;
N[CONTROL-1]=0;
N[CONTROL-1]=N[CONTROL-1]+48;
CONTROL++;
N[CONTROL-1]=(uint8_t)(ENTERO/C[N_INTERACCIONES-CONTROL]);
ENTERO=ENTERO-N[CONTROL-1]*C[N_INTERACCIONES-CONTROL];
N[CONTROL-1]=N[CONTROL-1]+48;}}


}}LCD_PRINT(N,POS_X,POS_Y);


}



/*ESTA FUNCION SE ENCARGA DE DESPLAZAR SOLO EL CURSOR DE LA PANTALLA UNA POSICION A LA DERECHA*/
void DESPLAZAMIENTO_DER(int ESPACIO){
int A=0;
while (A!=ESPACIO){SET_COMANDS(DESPLAZAMIENTO_CURSOR);A++;}}

/*ESTA FUNCION SE ENCARGA DE DESPLAZAR TODO EL CONTENIDO DE LA PANTALLA A LA DERECHA*/
void DESPLAZAMIENTO_DER_PANTALLA(int ESPACIO){
int A=0;
while (A!=ESPACIO){
PAUSE_FLUJO(1000,1,0,1);
SET_COMANDS(DESPLAZAMIENTO_PANTALLA); A++;}}

/*ESTA FUNCION TAN DESCRIPTIVA DE ENCARGA DE RETORNR EL CURSOR AL LA POSICION INICIAL DE LA PANTALLA LCD*/
void CURSOR_INICIO(){
POSICIONES_DIRECCIONES_DDRAM(CURSOR_HOME);}

/*ESTA FUNCION SE ENCARGA ENCENDER EL CURSOR DE PANTALLA JUNTO AL PARPADEO DE FUNDO DEL LCD*/
void B_ON(){
SET_COMANDS(BLINK_CURSOR_ON);}


/*ESTA FUNCION SE ENCARGA APAGAR EL CURSOR DE PANTALLA JUNTO AL PARPADEO DE FUNDO DEL LCD*/
void B_OFF(){
SET_COMANDS(BLINK_CURSOR_OFF);}

/*BUENO EL NOMBRE DE LA FUNCION NO DEJA A NADIE INDIFERENTE */
void LIMPIAR_PANTALLA(){
SET_COMANDS(DISPLAY_CLEAR);}

/*ESTA FUNCION SE ENCARGA DE INICIAR EL LCD VIA SOFTWARE YA QUE NORMALMENTE ES AUTOMATICO*/
void LCD_STAR(){



/*PARA DECLARAR EL PIN COMO SALIDA PARA EL ENABLE*/
DDR_X0=(1<<E_NABLE);
/*PARA DECLARAR LOS PINNE (RS RW D7 D6 D5 D4) PARA LA COMUNICACION DE 4 BITS AL LCD 20x4*/
DDR_X1|=(1<<R_S)|(1<<R_W)|(1<<D_7)|(1<<D_6)|(1<<D_5)|(1<<D_4);
PAUSE_FLUJO(50,1,0,1);
/*SET FUNCTION*/
PORT_X0=(1<<E_NABLE);
PORT_X1|=(1<<D_5)|(1<<D_4);
PORT_X0&=~(1<<E_NABLE);
PAUSE_FLUJO(100,1,0,1);
PORT_X0=(1<<E_NABLE);
PORT_X1|=(1<<D_5)|(1<<D_4);
PORT_X0&=~(1<<E_NABLE);
PAUSE_FLUJO(100,1,0,1);


PORT_X1|=(1<<D_5)|(1<<D_4);
PORT_X0&=~(1<<E_NABLE);


PAUSE_FLUJO(100,1,0,1);
PORT_X0=(1<<E_NABLE);PAUSE_FLUJO(5000,1,0,1);


PORT_X1=(1<<D_5)|(0<<D_4);PAUSE_FLUJO(5000,1,0,1);
PORT_X0&=~(1<<E_NABLE);PAUSE_FLUJO(5000,1,0,1);

/*SET FUNCTION*/
PAUSE_FLUJO(100,1,0,1);
int A_1=0;
while (A_1!=5){
/*VECTOR_DE[5]={(SET_FUCTION),(SET_FUCTION),(DISPLAY_CONTROL),(DISPLAY_CLEAR),(ENTRY_SET_MODE)};*/
//char VECTOR_DE[5]={0b00101011,0b00101011,0b00001111,0b00000001,0b00000110};
char VECTOR_DE[5]={0x2b,0x2b,0x0f,0x01,0x06};
char DATA_1=0b00000000;
char LSB_1=0b00000000,MSB_1=0b00000000;
DATA_1|=VECTOR_DE[A_1];
LSB_1|=DATA_1;
MSB_1|=(LSB_1>>4);
MSB_1&=0b00001111;
LSB_1&=0b00001111;
//_delay_us(30);
PORT_X0=(1<<E_NABLE);
PORT_X1=MSB_1;
PORT_X0&=~(1<<E_NABLE);
//_delay_us(60);
PORT_X0=(1<<E_NABLE);
PORT_X1=LSB_1;
PORT_X0&=~(1<<E_NABLE);
if (A_1!=4){PAUSE_FLUJO(80,1,0,1);}
else{PAUSE_FLUJO(40,1,0,1);}A_1++;}}

/*EN ESTE PEDASO DE CODIGO BORRAMOS EL ULTIMO CARACTER DE MAS QUE SE IMPRIME */
void BORRAR_DIGITO(){
SEND_DATA(CLEAR_DIGIT);}

/*ESTA FUNCION SE ENCARGA DE (VISUALIZAR)IMPRIMIR EN EL LCD CARCTERES EN LA PANTALLA*/
void LCD_PRINT(char cadena[],int X,int Y){
CURSOR_INICIO();
/*ESTE BLOQUE switch(Y) SE ENCARGA DE POSICIONAR EL
CURSOR EN LA POSICION QUE SE DESEA ESCRIBIR EN EL LCD*/
switch (Y){
case 0:X=X+0x00;POSICIONES_DIRECCIONES_DDRAM(X);break;
case 1:X=X+0x40;POSICIONES_DIRECCIONES_DDRAM(X);break;
case 2:X=X+0x14;POSICIONES_DIRECCIONES_DDRAM(X);break;
case 3:X=X+0x54;POSICIONES_DIRECCIONES_DDRAM(X);break;}
/*-------------------------------------------------------------------*/
int r=0;
while(cadena[r]!='\0')
{SEND_DATA(cadena[r]);r++;}


}

/*ESTA FUNCION SE ENCARGA DE (VISUALIZAR)IMPRIMIR EN EL LCD NUMEROS"CARACTERES" EN LA PANTALLA*/
void LCD_PRINT_NUMERO(const char DA[], int X, int Y){
CURSOR_INICIO();
switch (Y){
case 0:X=X+0x00;POSICIONES_DIRECCIONES_DDRAM(X);break;
case 1:X=X+0x40;POSICIONES_DIRECCIONES_DDRAM(X);break;
case 2:X=X+0x14;POSICIONES_DIRECCIONES_DDRAM(X);break;
case 3:X=X+0x54;POSICIONES_DIRECCIONES_DDRAM(X);break;}
/*-------------------------------------------------------------------*/

uint8_t r=0;
while(DA[r]!='\0')
{

	SEND_DATA(DA[r]);r++;}}
#endif